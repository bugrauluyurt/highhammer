name: build

on:
  workflow_dispatch:
    inputs:
      apps:
        description: 'Apps: (Write a list of apps to build. Ex: ["client-app", "api-core"]). Empty array creates images for all services.'
        default: '[]'
        required: false
  workflow_call:
    inputs:
      apps:
        description: 'Apps: (Write a list of apps to build. Ex: ["client-app", "api-core"]). Empty array creates images for all services.'
        type: string
        default: '[]'
        required: false
      tag:
        description: 'Next build tag:'
        type: string
        required: true

env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  ACR_ENDPOINT: ${{ secrets.ACR_ENDPOINT }}
  ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
  ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
  NX_CLOUD_AUTH_TOKEN: ${{ secrets.NX_CLOUD_AUTH_TOKEN }}
  NX_BRANCH: ${{ github.head_ref || github.ref_name }}

jobs:
  set-inputs:
    runs-on: ubuntu-latest
    steps:
      - name: Get branch name
        id: branch-name
        uses: tj-actions/branch-names@v6
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "16.17.0"
      - name: Generate inputs
        id: generate-inputs
        run: |
          # INPUT -> Apps
          echo "apps=$(node tools/dev-scripts/cmd-get-build-projects.js '${{inputs.apps}}')" >> $GITHUB_OUTPUT

          # INPUT -> Tag
          if [[ "${{ inputs.tag }}" == "" ]]; then
            echo "tag=$(git describe --abbrev=0 --tags | tr -d v)" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ inputs.tag }}" >> $GITHUB_OUTPUT
          fi

          # INPUT - Sha
          echo "sha=$(git rev-parse "$GITHUB_SHA")" >> $GITHUB_OUTPUT

          # INPUT - Branch
          echo "branch=${{ github.head_ref || github.ref_name }}" >> $GITHUB_OUTPUT
      - name: Print inputs
        run: |
          echo "APPS: ${{ steps.generate-inputs.outputs.apps }}"
          echo "SHA: ${{ steps.generate-inputs.outputs.sha }}"
          echo "BRANCH: ${{ steps.generate-inputs.outputs.branch }}"
          echo "TAG: ${{ steps.generate-inputs.outputs.tag }}"
    outputs:
      apps: ${{ steps.generate-inputs.outputs.apps }}
      sha: ${{ steps.generate-inputs.outputs.sha }}
      branch: ${{ steps.generate-inputs.outputs.branch }}
      tag: ${{ steps.generate-inputs.outputs.tag }}
  build:
    runs-on: ubuntu-latest
    needs: [set-inputs]
    if: ${{ fromJson(needs.set-inputs.outputs.apps)[0] }}
    strategy:
      max-parallel: 4
      matrix:
        node: ["16.17.0"]
        projectName: ${{fromJson(needs.set-inputs.outputs.apps)}}
    env:
      NODE: ${{ matrix.node }}
    steps:
      - name: Get branch name
        id: branch-name
        uses: tj-actions/branch-names@v6
      - name: Checkout
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GH_WORKFLOW_TOKEN }}
      - run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
      - name: Install pnpm
        uses: pnpm/action-setup@v2.2.4
        with:
          version: "7.x"
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node }}
          cache: 'pnpm'
      - name: Install dependencies
        # @INFO: Don't install only prod dependencies. Dev dependencies are needed to use the nx build and cloud.
        run: pnpm install
      - name: Build
        run: |
          git checkout ${{needs.set-inputs.outputs.sha}}
          pnpm nx run ${{ matrix.projectName }}:build
          rm -rf ./apps/${{matrix.projectName}}/dist
          # @INFO: For now skip the api-worker and e2e builds, since it is not being used. Skipping is done inside the 'cmd-get-build-projects.js' script
          cp -r ./dist/apps/${{matrix.projectName}}/ ./apps/${{matrix.projectName}}/dist/
      - name: Version monorepo
        id: version-monorepo
        run: |
          VERSION="$(git tag --points-at ${{needs.set-inputs.outputs.sha}})"

          if [[ $VERSION == "" ]]; then
            VERSION="${{needs.set-inputs.outputs.tag}}"
          fi

          # If there is no version set the version to the tag ref if the event source is push
          if [[ $VERSION == "" && "${{github.event_name == 'push'}}" == "true" ]]; then
            VERSION="$GITHUB_REF_NAME"
          fi

          # If there is still no version set the version to sha
          if [[ $VERSION == "" ]]; then
            VERSION="${{needs.set-inputs.outputs.sha}}"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
      - name: Version project
        id: version-project
        run: |
          VERSION_PROJECT="$(node tools/dev-scripts/cmd-generate-calver.js '${{matrix.projectName}}')"
          CURRENT_BRANCH="${{ steps.branch-name.outputs.current_branch }}"

          # Set the project version
          echo "version=$VERSION_PROJECT" >> $GITHUB_OUTPUT

          # Checkout to head after each commit.
          git checkout $CURRENT_BRANCH
          git pull origin $CURRENT_BRANCH

          # Bump the project version inside the package.json and push it without triggering the CI.
          node tools/dev-scripts/cmd-bump-project-version.js '${{matrix.projectName}}' $VERSION_PROJECT

          # Send it via git
          git add -A
          git commit -m "version(:rocket:): ${{matrix.projectName}} -> $VERSION_PROJECT [skip ci][skip release]"
          git push origin $CURRENT_BRANCH
      - name: Package
        run: |
          IMAGE_NAME="${{matrix.projectName}}"
          VERSION_PROJECT="${{steps.version-project.outputs.version}}"
          VERSION_MONOREPO="${{steps.version-monorepo.outputs.version}}"
          CONTAINER_TAG="$ACR_ENDPOINT/$IMAGE_NAME:$VERSION_PROJECT-$VERSION_MONOREPO"

          # - Docker login
          echo $ACR_PASSWORD | docker login $ACR_ENDPOINT -u $ACR_USERNAME --password-stdin
          # - Docker build
          docker build -t $CONTAINER_TAG -f ./apps/${{matrix.projectName}}/Dockerfile ./apps/${{matrix.projectName}}
          # - Docker push
          docker push $CONTAINER_TAG
